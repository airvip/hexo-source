---
title: 算法之冒泡排序的Python实现及分析
date: 2018-08-04 13:10:51
tags: 
    - 算法
---

> 青春是一部武侠小说，我们手执长剑，开拓属于自己的快意人生。

冒泡排序 (Bubble Sort) 是一种简单的排序算法。重复地询问要排序的元素，依次比较相邻的两个元素，如果顺序错误就把他们调换过来，直到没有元素再需要交换，则整个排序完成。这个算法的名字由来是因为越小 (或越大) 的元素会经由交换慢慢“浮”到数列的顶端。

<!-- more -->

这个算法的名字由来是因为越大（或越小）的元素会经由交换慢慢“浮”- 降序（或升序）排列到数列的顶端，就如同水中的气泡最终会上浮到水面一样，故名“冒泡排序”。

# 实现原理

下面通过升序的方式说下如何实现冒泡排序

1. 比较操作相邻的元素，如果前一个比后一个大，就调换它们的位置，否则，保持不变。
2. 对每一对相邻元素进行比较操作，从开始第一对到结尾的最后一对。结束后，最后的元素就是最大的数。
3. 再针对出最后一个元素外重复以上的步骤。
4. 持续对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![Bubble_sort_animation](/img/201808/bubble/Bubble_sort_animation.gif)

# Python 实现

```
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

def bubble_sort(nums):
    for i in range(len(nums) - 1):  # 控制冒泡排序进行次数
        for j in range(len(nums) - i -1):  # 控制每次比较的次数
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
    return nums

if __name__ == "__main__":
    list_nums = [32, 24, 19, 55, 30, 22, 8]
    list_res = bubble_sort(list_nums)
    print(list_res)
```

**运行结果**

```
[8, 19, 22, 24, 30, 32, 55]
```

# 程序分析

第一遍冒泡：初始列表 `[32, 24, 19, 55, 30, 22, 8]`

32 > 24 ,32 与 24 交换顺序，列表结果 `[24, 32, 19, 55, 30, 22, 8]`
32 > 19 ,32 与 19 交换顺序，列表结果 `[24, 19, 32, 55, 30, 22, 8]`
32 < 55 ,32 与 55 不做变动，列表结果 `[24, 19, 32, 55, 30, 22, 8]`
55 > 30 ,55 与 30 交换顺序，列表结果 `[24, 19, 32, 30, 55, 22, 8]`
55 > 22 ,55 与 22 交换顺序，列表结果 `[24, 19, 32, 30, 22, 55, 8]`
55 > 8   ,55 与 8   交换顺序，列表结果 `[24, 19, 32, 30, 22, 8, 55]`

至此，第一遍冒泡排序结束，最大值 55 已经冒泡到最后，下次冒泡就可以不对 55 作比较了。

第二遍冒泡：经过第一遍冒泡后的列表 `[24, 19, 32, 30, 22, 8, 55]`

24 > 19 ,24 与 19 交换顺序，列表结果 `[19, 24, 32, 30, 22, 8, 55]`
24 < 32 ,24 与 32 不做变动，列表结果 `[19, 24, 32, 30, 22, 8, 55]`
32 < 30 ,32 与 30 交换顺序，列表结果 `[19, 24, 30, 32, 22, 8, 55]`
32 < 22 ,32 与 22 交换顺序，列表结果 `[19, 24, 30, 22, 32, 8, 55]`
32 < 8 ,32 与 8 交换顺序，列表结果 `[19, 24, 30, 22, 8, 32, 55]`

这样经过多次冒泡，最终就可以得到一个升序的列表 `[8, 19, 22, 24, 30, 32, 55]`